"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var lodash = require("lodash");
var path = require("path");
var webpack = require("webpack");
var SetPublicPathPlugin_1 = require("@microsoft/loader-set-webpack-public-path/lib/SetPublicPathPlugin");
var ExternalsProcessor_1 = require("./ExternalsProcessor");
var OdspGulpTask_1 = require("./../OdspGulpTask");
function getBundleId(manifest, version) {
    if (version === void 0) { version = undefined; }
    return manifest.id + "_" + (version || manifest.version);
}
exports.getBundleId = getBundleId;
exports.fileLoaderExts = ['jpg', 'png', 'woff', 'eot', 'ttf', 'svg', 'gif'];
/**
 * Configures the @microsoft/gulp-core-build-webpack task with some smart defaults based on the package configuration.
 *
 * Example:
 *  IN:
 *    setConfig({
 *      webpack: <reference to webpack task>,
 *      webpackPublicPathOptions: <options for @microsoft/loader-set-webpack-public-path>,
 *      libraryName: <optional library name - set this if the library should be a global on the window>,
 *      configureExternalBundlingWebpackTask: <optional reference to ConfigureExternalBundlingWebpackTask task>
 *    })
 *    buildConfig.properties.entries = [{
 *      "entry": "./lib/App.js",
 *      "manifest": "./src/app.manifest.json",
 *      "outputPath": "dist/app.bundle.js"
 *    }]
 *    buildConfig.properties.externals = {
 *      "react-dom": "node_modules/react-dom/dist/react-dom.js",
 *      "react": "node_modules/react/dist/react.js",
 *      "flux": "node_modules/flux/dist/flux.js",
 *    }
 *
 *  OUT:
 *    set webpack config to (approximately):
 *    {
 *        context: ... root path ...,
 *        entry: { ... mapping of names to entries ... },
 *        resolve: {
 *          modules: [ ... root path + /node_modules ],
 *          alias: { }
 *        },
 *        output: {
 *          library: <library name, if provided>,
 *          libraryTarget: <library target, if specified> or 'amd',
 *          path: ... dist folder ...,
 *          filename: '[name].js',
 *          devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
 *          devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
 *        },
 *        externals: [ ... externals names ... ],
 *        module: {
 *          noParse: [ /\.map$/ ],
 *          rules: [
 *            {
 *              test: /\.css$/,
 *              use: [
 *                {
 *                  loader: `@microsoft/load-themed-styles'
 *                },
 *                {
 *                  loader: 'css-loader',
 *                  options: {
 *                    minimize: true
 *                  }
 *                }
 *              ]
 *            },
 *            {
 *              test: /\.(jpg|png|woff|eot|ttf|svg|gif)$/,
 *              use: [
 *                {
 *                  loader: '@microsoft/loader-cased-file',
 *                  options: {
 *                    name: '[name:lower]_[hash].[ext]'
 *                  }
 *                }
 *              ]
 *            },
 *            {
 *              test: /\.html$/,
 *              use: [
 *                {
 *                  loader: 'html-loader'
 *                }
 *              ]
 *            }
 *          ]
 *        },
 *        plugins: []
 *      }
 */
var ConfigureWebpackTask = (function (_super) {
    __extends(ConfigureWebpackTask, _super);
    function ConfigureWebpackTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'configure-webpack';
        _this.taskConfig = {
            libraryName: undefined,
            webpack: undefined,
            webpackPublicPathOptions: undefined,
            additionalConfiguration: undefined,
            configureExternalBundlingWebpackTask: undefined,
            statsObjectsDropLocation: undefined
        };
        _this._baseConfig = {
            module: {
                rules: [
                    {
                        use: [
                            {
                                loader: require.resolve('@microsoft/loader-load-themed-styles')
                            },
                            {
                                loader: require.resolve('css-loader'),
                                options: {
                                    minimize: true
                                }
                            }
                        ],
                        test: /\.css$/
                    },
                    {
                        use: [
                            {
                                loader: require.resolve('@microsoft/loader-cased-file'),
                                options: {
                                    name: '[name:lower]_[hash].[ext]'
                                }
                            }
                        ],
                        test: new RegExp(".(" + exports.fileLoaderExts.map(function (e) { return lodash.escapeRegExp(e); }).join('|') + ")((\\?|\\#).+)?$")
                    },
                    {
                        use: [
                            {
                                loader: require.resolve('html-loader')
                            }
                        ],
                        test: /\.html$/
                    }
                ],
                noParse: [/\.map$/]
            },
            resolve: {
                alias: {},
                modules: [
                    'node_modules',
                    'lib'
                ]
            }
        };
        return _this;
    }
    ConfigureWebpackTask.prototype.loadSchema = function () {
        return require('./configure-webpack.schema.json');
    };
    ConfigureWebpackTask.prototype.setConfig = function (config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        _super.prototype.mergeConfig.call(this, config);
    };
    ConfigureWebpackTask.prototype.getKarmaConfig = function (extraRules, externals, karmaTask) {
        var locAliases = {};
        try {
            var locResourceKeys = Object.keys(this.properties.discoveredLocalizedResources || {});
            var resolveResult = this.resolveResources(locResourceKeys, undefined, true, karmaTask);
            var locale = resolveResult.locales[0];
            for (var _i = 0, _a = resolveResult.localizedResourcesToBundle; _i < _a.length; _i++) {
                var resourceId = _a[_i];
                // Appending "$" to the resource ID to ensure paths under it aren't matched. See
                //  https://webpack.js.org/configuration/resolve/#resolve-alias
                locAliases[resourceId + "$"] = this.properties.discoveredLocalizedResources[resourceId][locale];
            }
        }
        catch (e) {
            karmaTask.logError("Error resolving localized resources for test. Tests may fail unexpectedly. Error: " + e);
        }
        var testAddons = {
            externals: externals,
            module: {
                rules: [
                    {
                        use: [
                            {
                                loader: 'imports',
                                options: {
                                    define: false
                                }
                            }
                        ],
                        test: /sinon\.js$/
                    }
                ]
            },
            plugins: [new webpack.DefinePlugin({
                    DEBUG: !this.buildConfig.production,
                    UNIT_TEST: true,
                    NPM_BUILD: false,
                    BUILD_NUMBER: '\'unit_test\'',
                    DATACENTER: !this.buildConfig.args['on-prem']
                })],
            resolve: {
                alias: locAliases
            }
        };
        (_b = testAddons.module.rules).push.apply(_b, extraRules);
        return this._appendToBaseConfig(testAddons);
        var _b;
    };
    ConfigureWebpackTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            completeCallback();
            return;
        }
        var configValidationResult = this._validateEntries();
        if (configValidationResult) {
            completeCallback(configValidationResult);
            return;
        }
        if (!this.buildConfig.properties) {
            this._logNoEntriesWarning();
            this._setWebpackConfig({});
            completeCallback();
            return;
        }
        // The ConfigureExternalBundlingWebpackTask will disable the second webpack task
        // when doing a dev build or in a project without localized resources.
        // This, however, breaks gulp serve. Therefore, we should ensure the webpack task is activated.
        // @todo 261553 - this should be removed when we do this refactor
        this.taskConfig.webpack.isEnabled = function () { return true; };
        var entries = this.properties.entries || [];
        var externalsKeys = ExternalsProcessor_1.getExternalsKeys(this);
        // Remove the specified linked externals to ensure they're bundled
        if (this.taskConfig.linkedExternalsToBundle && this.taskConfig.linkedExternalsToBundle.length) {
            for (var _i = 0, _a = this.taskConfig.linkedExternalsToBundle; _i < _a.length; _i++) {
                var linkedExternalToBundle = _a[_i];
                var linkedExternalToBundleIndex = externalsKeys.indexOf(linkedExternalToBundle);
                if (linkedExternalToBundleIndex !== -1) {
                    externalsKeys.splice(linkedExternalToBundleIndex, 1);
                }
            }
        }
        var localizedResources = this.properties.localizedResources || {};
        var localizedResourcesKeys = Object.keys(localizedResources);
        if (entries.length === 0) {
            this._logNoEntriesWarning();
            this.taskConfig.webpack.isEnabled = function () { return false; };
            completeCallback();
            return;
        }
        this.logVerbose(entries.length + " entries specified.");
        this.logVerbose(externalsKeys.length + " externals specified.");
        this.logVerbose(localizedResourcesKeys.length + " localized resources specified.");
        localizedResourcesKeys.forEach(function (key) {
            if (externalsKeys.indexOf(key) !== -1) {
                _this.logError("Invalid Configuration: Key \"" + key + "\" is specified in both externals and localizedResources.");
            }
        });
        var webpackPublicPathOptions = lodash.clone(this.taskConfig.webpackPublicPathOptions) || {};
        if (!webpackPublicPathOptions.systemJs) {
            lodash.merge(webpackPublicPathOptions, {
                scriptName: {
                    name: '[name]_?[a-zA-Z0-9-_]*\.js',
                    isTokenized: true
                }
            });
        }
        // When we loop through the config entries, record the manifests so we can use them later if we need to
        var manifests = [];
        // Users can use the --entry to control which entries actually get bundled
        // This value can match the GUID or the alias
        var entryParam = this.buildConfig.args['entry']; // tslint:disable-line:no-string-literal
        this.properties.bundleEntries = [];
        var webpackEntries = {};
        var foundEntry;
        for (var _b = 0, entries_1 = entries; _b < entries_1.length; _b++) {
            var entry = entries_1[_b];
            var entryName = path.basename(entry.outputPath, '.js');
            webpackEntries[entryName] = path.join(this.buildConfig.rootPath, entry.entry);
            var manifest = this.getManifest(entry.manifest);
            // If the manifest version is "*", replace it with the package version. Do this here to make sure the
            //  bundle's name doesn't contain the "*" version
            if (manifest.version === '*') {
                var manifestVersion = this.getPackageVersion();
                manifest.version = manifestVersion;
            }
            var shouldBundleEntry = entryParam === undefined ||
                (entryParam && manifest &&
                    (manifest.id.toLowerCase() === entryParam.toLowerCase() ||
                        manifest.alias.toLowerCase() === entryParam.toLowerCase()));
            if (entryParam === undefined || shouldBundleEntry) {
                foundEntry = true;
                this.properties.bundleEntries.push({
                    entryName: entryName,
                    configEntry: entry,
                    nonLocalizedEntrypointPath: path.join(this.outputDirectory, entryName + ".js"),
                    manifest: manifest
                });
                if (manifest) {
                    manifests.push(manifest);
                }
            }
        }
        if (entryParam && !foundEntry) {
            completeCallback("The \"--entry\" flag was specified, but \"" + entryParam + "\" did not match " +
                "the id or alias of any entries listed in config.json");
            return;
        }
        this.properties.webpackLibraryName = this.taskConfig.libraryName || (function () {
            if (manifests.length === 0) {
                // If there are no manifests, it doesn't appear as though we're generating a bundle that will be
                //  loaded on the page, because the module loader requires an ID, so we shouldn't need to worry about
                //  collisions in the webpackJsonp function.
                return undefined;
            }
            else if (manifests.length === 1) {
                return getBundleId(manifests[0]);
            }
            else {
                // If there are multiple manifests, this is a project that is producing multiple components. Because
                //  we need something unique for the webpack JSONP function, we'll just concatenate the IDs and then hash them.
                //  In the post-bundle steps, we'll replace the "define(<name>, ..." name with the real IDs. When we update
                //  this task to support multiple webpack configurations, we can separate each bundle to have its own library
                //  name.
                var packageVersion_1 = _this.getPackageVersion();
                _this.properties.webpackLibraryNameIsTemporary = true;
                return _this.getChecksum(manifests.map(function (manifest) { return getBundleId(manifest, packageVersion_1); }).join(''));
            }
        })();
        var configAddons = {
            context: this.buildConfig.rootPath,
            devtool: this.buildConfig.production ? undefined : 'source-map',
            entry: webpackEntries,
            externals: externalsKeys.concat(localizedResourcesKeys),
            module: {
                rules: [
                    {
                        test: /\.js$/,
                        enforce: 'pre',
                        use: require.resolve('source-map-loader')
                    }
                ]
            },
            output: {
                chunkFilename: '[id].[name]_[chunkhash].js',
                filename: '[name].js',
                library: this.properties.webpackLibraryName,
                libraryTarget: this.taskConfig.libraryTarget || 'amd',
                path: this.outputDirectory,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            },
            plugins: [
                new SetPublicPathPlugin_1.default(webpackPublicPathOptions)
            ]
        };
        this._includeStatsPlugin(path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, "stats"), configAddons);
        if (this.taskConfig.statsObjectsDropLocation) {
            var resolvedPath = path.resolve(this.buildConfig.rootPath, this.taskConfig.statsObjectsDropLocation);
            this._includeStatsPlugin(resolvedPath, configAddons);
        }
        if (this.buildConfig.production) {
            configAddons.plugins.push(new webpack.optimize.UglifyJsPlugin({
                compress: {
                    dead_code: true,
                    warnings: false
                },
                mangle: true
            }));
        }
        var buildNumber = undefined;
        if (process.env.BUILD_BUILDNUMBER) {
            buildNumber = "'" + process.env.BUILD_BUILDNUMBER.toLowerCase() + "'";
        }
        configAddons.plugins.push(new webpack.DefinePlugin({
            DEBUG: !this.buildConfig.production,
            UNIT_TEST: false,
            NPM_BUILD: this.npmBuild,
            BUILD_NUMBER: buildNumber
        }));
        var config = this._appendToBaseConfig(configAddons);
        if (this.taskConfig.configureExternalBundlingWebpackTask) {
            this.taskConfig.configureExternalBundlingWebpackTask.tinkerWithBaseWebpackConfig(config);
        }
        if (this.taskConfig.additionalConfiguration) {
            config = this.taskConfig.additionalConfiguration(config);
        }
        this._setWebpackConfig(config);
        completeCallback();
        return;
    };
    /**
     * Modify the localized webpack config to make sure the end result is correct.
     *
     * @internal
     */
    ConfigureWebpackTask.prototype.tinkerWithLocConfig = function (config) {
        config.output.libraryTarget = this.taskConfig.libraryTarget || 'amd';
    };
    ConfigureWebpackTask.prototype._includeStatsPlugin = function (dropPath, config) {
        // tslint:disable-next-line:typedef variable-name
        var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
        var lastDirName = path.basename(this.buildConfig.rootPath);
        config.plugins.push(new BundleAnalyzerPlugin({
            openAnalyzer: false,
            analyzerMode: 'static',
            reportFilename: path.join(dropPath, lastDirName + ".stats.html"),
            generateStatsFile: true,
            statsFilename: path.join(dropPath, lastDirName + ".stats.json"),
            logLevel: 'error'
        }));
    };
    ConfigureWebpackTask.prototype._appendToBaseConfig = function (config) {
        return lodash.mergeWith({}, this._baseConfig, config, function (value1, value2) {
            if (lodash.isArray(value1) && lodash.isArray(value2)) {
                return lodash.concat(value1, value2);
            }
            else {
                return undefined;
            }
        });
    };
    ConfigureWebpackTask.prototype._logNoEntriesWarning = function () {
        // @TODO: SPPPlat VSO 221536
        // this.logWarning('No entries are defined, so no bundles will be produced.');
    };
    ConfigureWebpackTask.prototype._setWebpackConfig = function (config) {
        var webpackTask = this.taskConfig.webpack;
        var sourceMapWarningSuppression = /Cannot find SourceMap \'.+\'\: Error\:/;
        var suppressedWarnings = webpackTask.taskConfig.suppressWarnings || [];
        if (webpackTask) {
            webpackTask.setConfig({
                config: config,
                configPath: null,
                suppressWarnings: suppressedWarnings.concat([sourceMapWarningSuppression])
            });
        }
    };
    ConfigureWebpackTask.prototype._validateEntries = function () {
        if (this.properties.entries) {
            var outputNames = new Set();
            var entrypointPaths = new Set();
            for (var _i = 0, _a = this.properties.entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                var outputName = path.basename(entry.outputPath).toUpperCase();
                if (outputNames.has(outputName)) {
                    return "Output name \"" + outputName + "\" occurs in multiple config.json entries. This is not supported.";
                }
                else {
                    outputNames.add(outputName);
                }
                var entrypointPath = path.resolve(path.join(this.buildConfig.rootPath, entry.entry)).toUpperCase();
                if (entrypointPaths.has(entrypointPath)) {
                    return "Entry path \"" + entrypointPath + "\" occurs in multiple config.json entries. This is not supported.";
                }
                else {
                    entrypointPaths.add(entrypointPath);
                }
            }
        }
    };
    return ConfigureWebpackTask;
}(OdspGulpTask_1.default));
exports.ConfigureWebpackTask = ConfigureWebpackTask;

//# sourceMappingURL=ConfigureWebpackTask.js.map
